---
title: "Final_Report"
author: "Adriano Martinelli, Chrysa Papadopoulou, Iliana Papadopoulou" 
date: "23/12/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
Single-cell RNA sequencing technologies allow the quantification of RNA molecules in biological samples in counts of reads mapped to the genes. Indeed, they are used to profile genome-wide high-resolution instances of gene expression activity and modifications in individual cells over time as well as monitor discrepancies in gene expression in different groups or treatments across conditions.However, the presence of multi-condition scRNA-seq datasets dictates the need to perform sample-level inferences.    

The aim of this project is to extend the simulation framework Muscat (Multi-sample multi-group scRNA-seq analysis tools) [1] established in the group of Prof. Mark Robinson in collaboration with Pierre Luc Germain. More precisely, the ``muscat`` simulation framework currently used in the group does not take the gene-gene correlation into account, sampling each gene in each cell independently. It is suspected that this may bias the evaluation of downstream analysis techniques. Since it is well known that gene-gene correlation is observed in real world data sets, the goal of our analysis is to explore the effect of gene-gene correlation on the differential expression (DE) analysis, while compairing it with the ``muscat`` simulation framework.

# Datasets

For performimg our simulations we utilized the single-cell RNA-seq of mouse cortex injected with Lipopolysaccharide (LPS) or with a vehicle treatment dataset (Crowell et al.)[1].

The class SingleCellExperiment keeps track of the counts and their associated metadata within a single object.

![](SingleCellExperiment_class.png)

## Preprocessing 

Firstly, we filter the doublet cells, produced directly from counts using overclustering-based generation of artifical doublets, separately on each sample using the scDblFinder class [2]. After removing genes that are not detected across all cells, we implement Quality control and filtering, using the R scater package [3], to correct for technical effects that distort the downstream analysis. In the provided SingleCellExperiment object, we also integrate various per-cell quality control statistics from perCellQCMetrics function. The first plot demonstrates an expected increasing number of detected genes with an increasing total count. Each point represents a cell that is coloured according to its cluster id. We then remove cells that have very few or many detected genes. Therefore, in the second figure we plot the distributions of QC metrics, the observation of which helps us to select the apprppriate thresholds for removing possible low-quality genes. 

A better way to choose these thresholds is implemented via the isOutlier function , where we exclude cells whose feature counts, number of detected features, and percentage of mitochondrial genes go beyond 2 Median Absolute Deviations (MADs) of the median and the percentage of mitochondrial genes overcomes 8\%. In addition, we plot the top 50  most-expressed features and subsequently remove the lowly expressed genes. Indeed, in the plot the rows correspond to genes and bars describe the expression of genes in single cells. Genes are sorted based on the median expression of each gene, which is indicated by circles.

We then calculate the distribution of percentages of the variance of the normalized log-expression values across cells that is explained by each variable/factor in the colData of our sce object, using the getVarianceExplained() function. In the density plot we observe that the percentages are generally small (0.08%,0.1%, 0.5%), meaning that that the expression profiles of most genes are not strongly associated with these factors. Finally, we visualize the expression values for a subset of genes (e.g the first 6 genes) across cells using the plotExpression() function. [4]


```{r, warning=FALSE}
#Load data
suppressPackageStartupMessages({
library(SingleCellExperiment)
library(scater)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(grid)
library(edgeR)
library(irlba)
library(muscat)
library(countsimQC)
library(TMB)
library(cowplot)
library(scDblFinder)
library(dplyr)
library(UpSetR)
library(uwot)
library(Rtsne)  
  })

source('./Preprocessing_fun.R', echo=FALSE)
set.seed(123)

#Load object
sce = readRDS("week13_SCE_clustered.rds")
```

```{r, fig.cap=c('Plotting data','Distributions of QC metrics',"Top 50 most-expressed features")}

sce= prep_steps(sce)

```

# Methods

## Simulation
We created a simulation framework that produces a correlation structure in the simulated counts to explore the effect of such correlation on analysis techniques. To make our results comprable to existing methods (muscat simulation framework) we tried to produce a simulation that allows us to generate data sets with similar characteristics as the muscat framework in terms of number of cells, number of samples, number of cluster and the distribution of those cells across samples and clusters. The typical input data set is a ``SingleCellExperiment`` file which consits of multiple wild types samples containing multiple cell types.

The pipeline of the simulation is:
* Generate correlation structure reflected in mean counts for each gene and cell
* Sample counts for each cell type and sample from a negative binomial distribution based on mean counts, gene-wise dispersion and library size
* Concatenate simulated data into a ``SingleCellExperiment``

### Generation of correlation structure
In a first step the ``SingleCellExperiment`` is subsected into each sample. Each sample is further subsected into the single cell types. This is the original data for a single simulation round, i.e. we construct the correlation structure for each cell type of each sample seperately as follows:

* Perform PCA on the data with gene as features
* Compute _k_-nearest neighbours of a cell
* Randomly select _N_ cells from the nearest neighbours with replacement
* Average the top principal components to create a artificial cell
* Project artificial cell from PCA space back into logcounts space

By averaging different subsets we obtain a correlation structure among the artificial cells. Note that we have to repeate this procedure for each cell type of each sample.

### Construct simulated ``SingleCellExperiment``
To obtain a complete artificial dataset we need to generate multiple samples with different cell types. Therefore we repeat the above described procedure for each cell type in a sample and for each sample in the original data set. This gives us a matrix of mean logcounts of the artificial cells each associated with a given cell type and sample id. We use convert this mean logcount matrix back to a count matrix and use this mean count matrix together with the gene-wise dispersion computed from the original data set as well as the library size of a given cell to generate artifical counts by sampling from a negative binomial distribution. This results in the final artifical count matrix.

### Simulation work-flow overview
We summarise this section by giving an overview of the whole procedure to generate the artificial counts:

* Prepare original data for simulation with ``prepSim()`` from ``muscat`` framework to filter the original data set
* For each sample and cell type generate the mean count based on PC averaging of a subset of _k_-nearest neigbours
* Based on mean count matrix, gene-wise dispersion and library size sample artificial counts from negative binomial

```{r}
#Load simulation functions
source('./fun.R', echo=FALSE)
```

## Run simulation
```{r}
##Prep data for simulation
if(length(grep("sce_prep",list.files()))){
  sce_prep = readRDS("sce_prep.RDS")
}else{
  sce_prep <- prepSCE(sce,
  cluster_id = "cluster_id",
  sample_id = "sample_id",
  group_id = "group_id",
  drop = FALSE)
  sce_prep <- prepSim(sce_prep)
  saveRDS(sce_prep, "sce_prep.RDS")
  counts(sce_prep) = as.matrix(counts(sce_prep))
  sce_prep = logNormCounts(sce_prep)
}

n_cluster = length(unique(colData(sce_prep)$cluster_id))
freq_cluster = table(colData(sce_prep)$cluster_id)
freq_cluster = freq_cluster / sum(freq_cluster)
n_sample = length(unique(colData(sce_prep)$sample_id))
n_group = 2

#Set params MUSCAT
n_genes = nrow(sce_prep)
n_cells_muscat = 100*n_sample
p_dd = c(0.9, 0, 0.1, 0, 0, 0)
probs = list(cluster = freq_cluster,
             sample = rep(1/n_sample, n_sample),
             group = rep(1/n_group, n_group))
lfc = 4

#Set params our simulation
n_comp = 10
n_cells = rep(n_cells_muscat / n_sample, n_sample)
kNN = 10
kNN_subsample = 5
#logFC = list(magnitude = lfc, proportion = p_dd[3]) #corresponds to p_dd
verbose = 0

#Run simulations
sce_muscat = simData(sce_prep, n_genes = n_genes, n_cells = n_cells_muscat, p_dd = p_dd, probs = probs, lfc = lfc)

#Extract meta data
meta = metadata(sce_muscat)$gene_info %>% select(cluster_id, logFC, sim_gene)
meta$logFC[is.na(meta$logFC)] = 0 

#Set up sce to replicate muscat simulation
gene_id = meta %>% filter(cluster_id == "Neuronal_excit") %>% select(sim_gene)
idx = sapply(gene_id$sim_gene, function(x){
  which(x == rownames(sce_prep))
})
#hist(table(idx))
sce_prep2 = sce_prep[idx,]
logFC = list("muscat_data" = meta)
library_size_muscat = colSums(counts(sce_muscat))

#Run simulation
sce_sim = create_dataset(sce_prep2, n_comp, n_cells, kNN, kNN_subsample, n_sample, logFC, probs, library_size_muscat,verbose)

#Compare metadata
#head(metadata(sce_muscat)$gene_info,10)
#head(metadata(sce_sim)$gene_info,5)
#metadata(sce_sim)$cluster_info
```

## Augment data sets
```{r}
#Convert counts
sce_muscat = logNormCounts(sce_muscat)
logcounts(sce_prep) = as.matrix(logcounts(sce_prep))
counts(sce_prep) = as.matrix(counts(sce_prep))

#Populate sce_sim with reducedDim
sce_sim = runPCA(sce_sim)
sce_sim = runUMAP(sce_sim)
sce_sim = runTSNE(sce_sim)

#Populate sce_muscat with reducedDim
sce_muscat = runPCA(sce_muscat)
sce_muscat = runUMAP(sce_muscat)
sce_muscat = runTSNE(sce_muscat)

#Populate sce_wt with reducedDim
sce_prep = runPCA(sce_prep)
sce_prep = runUMAP(sce_prep)
sce_prep = runTSNE(sce_prep)
```

## Compare simulations
```{r}
subsample = sample(1:ncol(sce_prep), ncol(sce_sim))
  
#Distribution of counts
par(mfrow=c(3,1))
hist(logcounts(sce_prep)[sample(1:nrow(sce_prep), nrow(sce_sim))])
hist(logcounts(sce_muscat))
hist(logcounts(sce_sim))

#Sum of counts
countSum = data.frame(sce_prep = sum(counts(sce_prep)[,subsample]),
                      sce_muscat = sum(counts(sce_muscat)),
                      sce_sim = sum(counts(sce_sim)))
par(mfrow=c(1,1))
barplot(as.matrix(countSum), main = "Count sum of different SingleCellExperiment data sets")

table(metadata(sce_sim)$category)
table(metadata(sce_muscat)$category)

#Plot dim reductions
par(mfrow=c(3,1))
plotReducedDim(sce_prep, "PCA", colour_by = "cluster_id")
plotReducedDim(sce_muscat, "PCA", colour_by = "cluster_id", shape_by = "group_id")
plotReducedDim(sce_sim, "PCA", colour_by = "cluster_id", shape_by = "group_id")

par(mfrow=c(3,1))
plotReducedDim(sce_prep, "UMAP", colour_by = "cluster_id")
plotReducedDim(sce_muscat, "UMAP", colour_by = "cluster_id", shape_by = "group_id")
plotReducedDim(sce_sim, "UMAP", colour_by = "cluster_id", shape_by = "group_id")

par(mfrow=c(3,1))
plotReducedDim(sce_prep, "TSNE", colour_by = "cluster_id")
plotReducedDim(sce_muscat, "TSNE", colour_by = "cluster_id", shape_by = "group_id")
plotReducedDim(sce_sim, "TSNE", colour_by = "cluster_id", shape_by = "group_id")

#Cell-cell correlation structure
CellCellCor = list("sce_prep" = cor(counts(sce_prep)[,subsample]),
                   "sce_muscat" = cor(counts(sce_muscat)),
                   "sce_sim" = cor(counts(sce_sim)))

x = 1:ncol(sce_muscat)
par(mfrow = c(1,2))
image(x,x,CellCellCor$sce_muscat, axes = FALSE, xlab = '', ylab = '')
image(x,x,CellCellCor$sce_sim, axes = FALSE, xlab = '', ylab = '')

#Gene-Gene correlation structure
#GeneGeneCor = list("sce_prep" = cor(t(counts(sce_prep)[,subsample])),
#                   "sce_muscat" = cor(t(counts(sce_muscat))),
#                   "sce_sim" = cor(t(counts(sce_sim))))

# x = 1:nrow(sce_muscat)
# par(mar = c(5,6,6,4), cex = 0.5)
# image(x,x,GeneGeneCor$sce_muscat, axes = FALSE, xlab = '', ylab = '')

#Run count
DESeq_sim = DESeq2::DESeqDataSetFromMatrix(counts(sce_sim), colData(sce_sim), ~cluster_id*group_id)
DESeq_muscat = DESeq2::DESeqDataSetFromMatrix(counts(sce_muscat), colData(sce_muscat), ~cluster_id*group_id)
DESeq_prep = DESeq2::DESeqDataSetFromMatrix(counts(sce_prep), colData(sce_prep), ~cluster_id)

QCdata = list("Original" = DESeq_prep, "Muscat" = DESeq_muscat, "Sim" = DESeq_sim)

countsimQCReport(ddsList = QCdata, outputFile = "countsim_report_muscat_libsize.html",
                 outputDir = "./CountSimReport_muscatlibsize/", outputFormat = "html_document", 
                 showCode = FALSE, forceOverwrite = TRUE,
                 savePlots = TRUE, description = "This is my test report.", 
                 maxNForCorr = 25, maxNForDisp = Inf, 
                 calculateStatistics = TRUE, subsampleSize = 25,
                 kfrac = 0.01, kmin = 5, 
                 permutationPvalues = FALSE, nPermutations = NULL)

```

## DE Analysis

The goal is to monitor population-specific state modifications across conditions. Consequently, we will test both aggregation-based approches (pbDS), which explicitly consider *pseudobulk* data and mixed models, which explicitly consider cell-level measurements (mmDS). In all cases, each gene is checked for state changes in each cluster.

Firstly, we aggregate measurements for each sample in each cluster to pseudobulk and create a MDS plot in pseuobulk-level to study the properties of samples. After reformatting the results, we filter them to keep hits with FDR < 5\% and visualize the top hits with the lowest adj. p-value in each cluster in the case of pseudobulk methods. On the other hand, in cell-level measurements, we use a mixed model for each gene, without aggragation beforehand. 


```{r,message=FALSE}
source('./Muscat_Simulation_Fun.R', echo=FALSE)
```


```{r,fig.width=5}

Simulation_DS_analysis<-function(sce,pos,sim_type,methods){
  
  violin_1_plot  = list()
  violin_2_plot  = list()
  upset_plot_cluster = list()
  ds_expression_plot = list()
  TPR.vs.FDR_plot = list()

  num = 0
  for (method in methods){
    num = num +1
    method_pieces <- strsplit(method, "_")
    method_substring <- matrix(unlist(method_pieces), ncol=3, byrow=TRUE)
    
    if (pos!=3 && pos!=4){
      print("Invalid gene_info argument position")
      break
    }
    
    topnumber = 0
    vst = NULL
    ds <- list()
    if (grepl("mm_",method)){
      if (method_substring[2] == "dream"){
        topnumber = 8
      }
      else if (method_substring[2] == "vst"){
        topnumber = 8
        vst = method_substring[3]
      }
      ds <- DS.analysis.mm(sce,method_substring[2],method_substring[1],vst,topnumber,pos)
      
      #Visualization
      plots <- DS.analysis.Visualization.mm(ds,method_substring[2],method_substring[1],vst,topnumber,num,sim_type)
      
    }
    else{
      if (!(method_substring[1] == "logcounts" && method_substring[3] == "edgeR")){
        topnumber = 8
      }
      
      #DS pb analysis
      ds <- DS.analysis.pd(sce,method_substring[2],method_substring[1],method_substring[3], topnumber,pos)
      #Visualization
      plots <- DS.analysis.Visualization.pb(ds,method_substring[2],method_substring[1],method_substring[3],topnumber,num,sim_type)
    
    }
    for(element in plots){
      if (!is_null(element)){
        suppressWarnings(print(element)) 
      }
    }
  }
  
}
```

##  Muscat Simulation
```{r}
suppressWarnings({
methods <- list("sum_counts_edgeR","sum_counts_limma-voom","mean_logcounts_edgeR",
         "mean_logcounts_limma-voom","mm_dream","mm_nbinom","mm_vst_DESeq")

Simulation_DS_analysis(sce_muscat,3,"muscat",methods)

})
```

## Correlation Structure Simulation
```{r}
suppressWarnings({
methods <- list("sum_counts_edgeR","sum_counts_limma-voom","mean_logcounts_edgeR",
         "mean_logcounts_limma-voom")

Simulation_DS_analysis(sce_sim,4,"correlation_structure",methods)

})
```


## Simulation Quality Control
```{r}
res_muscat = readRDS("output/muscat/DS_results_counts_sum_edgeR.rds")
res_sim = readRDS("output/correlation_structure/DS_results_counts_sum_edgeR.rds")
```


```{r}
#Obtain all idx for the genes in DE analysis
idx_sim_ne = sapply(res_sim$table$B$Neuronal_excit$gene, function(x){
  which(x == rownames(sce_sim))
})

idx_sim_ni = sapply(res_sim$table$B$Neuronal_inhib$gene, function(x){
  which(x == rownames(sce_sim))
})

idx_mu_ne = sapply(res_muscat$table$B$Neuronal_excit$gene, function(x){
  which(x == rownames(sce_muscat))
})

idx_mu_ni = sapply(res_muscat$table$B$Neuronal_inhib$gene, function(x){
  which(x == rownames(sce_muscat))
})

```

```{r}
#Construct vectors of logFC for the genes in the analysis
mm = metadata(sce_muscat)
ms = metadata(sce_sim)

lfc_mm_ne = mm$gene_info %>% filter(cluster_id == "Neuronal_excit") %>% select(logFC)
lfc_mm_ne = lfc_mm_ne$logFC
lfc_mm_ne[is.na(lfc_mm_ne)] = 0
lfc_mm_ne = lfc_mm_ne[idx_mu_ne]

lfc_mm_ni = mm$gene_info %>% filter(cluster_id == "Neuronal_inhib") %>% select(logFC)
lfc_mm_ni = lfc_mm_ni$logFC
lfc_mm_ni[is.na(lfc_mm_ni)] = 0
lfc_mm_ni = lfc_mm_ni[idx_mu_ni]

lfc_ms_ne = ms$gene_info2 %>% filter(cluster_id == "Neuronal_excit") %>% select(logFC)
lfc_ms_ne = lfc_ms_ne$logFC
lfc_ms_ne = lfc_ms_ne[idx_sim_ne]

lfc_ms_ni = ms$gene_info2 %>% filter(cluster_id == "Neuronal_inhib") %>% select(logFC)
lfc_ms_ni = lfc_ms_ni$logFC
lfc_ms_ni = lfc_ms_ni[idx_sim_ni]

lfc_res_mm_ne = res_muscat$table$B$Neuronal_excit$logFC
lfc_res_mm_ni = res_muscat$table$B$Neuronal_inhib$logFC

lfc_res_ms_ne = res_sim$table$B$Neuronal_excit$logFC
lfc_res_ms_ni = res_sim$table$B$Neuronal_inhib$logFC
```

## Upset plots
```{r}
#Construct vectors of p.adj for the genes in the analysis
mm = metadata(sce_muscat)
ms = metadata(sce_sim)

DE_mm_ne = mm$gene_info %>% filter(cluster_id == "Neuronal_excit") %>% select(logFC)
DE_mm_ne = DE_mm_ne$logFC
DE_mm_ne[is.na(DE_mm_ne)] = 0
DE_mm_ne = DE_mm_ne[idx_mu_ne]
DE_mm_ne[DE_mm_ne != 0] = 1 #set all DE genes to 1

DE_mm_ni = mm$gene_info %>% filter(cluster_id == "Neuronal_inhib") %>% select(logFC)
DE_mm_ni = DE_mm_ni$logFC
DE_mm_ni[is.na(DE_mm_ni)] = 0
DE_mm_ni = DE_mm_ni[idx_mu_ni]
DE_mm_ni[DE_mm_ni != 0] = 1 #set all DE genes to 1

DE_ms_ne = ms$gene_info2 %>% filter(cluster_id == "Neuronal_excit") %>% select(logFC)
DE_ms_ne = DE_ms_ne$logFC
DE_ms_ne = DE_ms_ne[idx_sim_ne]
DE_ms_ne[DE_ms_ne != 0] = 1

DE_ms_ni = ms$gene_info2 %>% filter(cluster_id == "Neuronal_inhib") %>% select(logFC)
DE_ms_ni = DE_ms_ni$logFC
DE_ms_ni = DE_ms_ni[idx_sim_ni]
DE_ms_ni[DE_ms_ni != 0] = 1

DE_res_mm_ne = rep(0, nrow(res_muscat$table$B$Neuronal_excit))
DE_res_mm_ne[res_muscat$table$B$Neuronal_excit$p_adj.loc <= 0.05] = 1
DE_res_mm_ni = rep(0, nrow(res_muscat$table$B$Neuronal_inhib))
DE_res_mm_ni[res_muscat$table$B$Neuronal_inhib$p_adj.loc <= 0.05] = 1

DE_res_ms_ne = rep(0, nrow(res_sim$table$B$Neuronal_excit))
DE_res_ms_ne[res_sim$table$B$Neuronal_excit$p_adj.loc <= 0.05] = 1
DE_res_ms_ni = rep(0, nrow(res_sim$table$B$Neuronal_inhib))
DE_res_ms_ni[res_sim$table$B$Neuronal_inhib$p_adj.loc <= 0.05] = 1

#Upset true vs predicted
upset_data_mm_ne = data.frame(True = DE_mm_ne, Predicted = DE_res_mm_ne)
upset_data_mm_ni = data.frame(True = DE_mm_ni, Predicted = DE_res_mm_ni)
upset_data_ms_ne = data.frame(True = DE_ms_ne, Predicted = DE_res_ms_ne)
upset_data_ms_ni = data.frame(True = DE_ms_ni, Predicted = DE_res_ms_ni)
```

## For Further use
```{r}
# Concatenate all .rds files together
library(tidyverse)
sce_muscat_all_methods <- do.call('rbind', lapply(list.files(path = "output/muscat", full.names = TRUE), readRDS))
```

```{r}
print(sce_muscat_all_methods)
```

```{r}
sce_sim_all_methods <- do.call('rbind', lapply(list.files(path = "output/muscat", full.names = TRUE), readRDS))
```

```{r}
print(sce_sim_all_methods)
```


# Results

We simulate 7 methods in total, including sum counts in edgeR, sum counts in limma-voom, mean logcounts in edgeR, mean logcounts in limma-voom, mm dream, mm nbinom and mm vst DESeq, where in each case DE genes are retrieved when adj. p-value <0.05. For each method we calculate the ground truth, which is included in the category column of the metadata of our sce object. [5]

## Visualization tools

For visualization analysis, we create violin plots, which constitute expression profiles for the top-8 DS genes with the lowest adj. p-value in Neuronal_excit and Neuronal_inhib clusters using the `plotExpression` function. We also use t-SNE representations colored by the expression of the top-8 DS genes, sampling at most 100 cells from each cluster. Moreover, we calculate the true positive rate (TPR) vs false discovery rate (FDR) for each method. In the end, we produce UpSet-plots for each method that visualizes the number of DE genes intersecting across clusters or the ones that are unique, as well as the number of DE genes that are shared between the predictions and the ground truth. [5]

## Simulation of Muscat

Muscat simulation produces five plots for each of the seven studied methods. 

For methods sum counts edgeR, sum counts limma-voom , mean logcounts edgeR and mean logcounts limma-voom in the Neuronal_excit cluster, we observe that the distribution of the logcounts for genes 10 and 1001 detects more outliers for the LC025_WTA sample, while in gene 1007 for samples LC025_WTA and LC025_WTB, the distribution involves a larger number of logcounts (Figures 1, 6, 11, 15). In the Neuronal_inhib cluster, we observe highter expression of logcounts for most genes compared to the previous case and gene 1008 involves diversity in logcounts in all samples (Figures 2, 7, 12, 16).
  
In methods mm-dream and mm-nbinom, in cluster Neuronal_excit, genes 1008, 1017 and 1023 are highly expresssed across all samples. On the other hand, in Neuronal_inhib cluster, we observe the presence of outliers in genes 1037, 1039 and 105 for samples LC016_WTB and LC025_WTB together with highly expressed logcounts. Method mm-vst-DESeq contains the largerst amount of logcounts across all samples and genes compared to all the aforementioned cases.
  
Methods sum counts edgeR, sum counts limma-voom , mean logcounts edgeR and mean logcounts limma-voom share the same upset plots with 44 differentially expressed genes for Neuronal_inhib cluster, 2230 for Neuronal_excit cluster and 4718 equally shared between the two clusters (Figures 3, 8, 13, 17). Methods mm-dream and mm-nbinom produce 1361 differentially expressed genes in Neuronal_excit cluster and both clusters share 1133 (Figures 22, 27). Method mm-vst-DESeq reaches different results compared to the other methods (Figure 31).
  
In the t-SNE representation figures all top genes share approximately the same cell-populations. However, cell-populations are not well-separated from one another (Figures 4, 9, 18, 23).
   
Moreover, we plot the observed overall true positive rate (TPR) and false discovery rate (FDR) values at 1\%, 5\%, and 10\% FDR cutoffs. Dashed lines represent the desired FDRs. Counts sum in edgeR method presents the best performance as it reaches the hightest TPR and lowest FDR followed by mm-dream. Next are the counts sum and logcounts in limma-voom,mm-vst-DESeq and logcounts mean in edgeR. The mm-nbinom underperforms as it contains an abnormally large FDR and nearly zero TPR (Figures 5, 10, 14, 19, 24, 28, 32).


## Simulation of Correlation Structure 

In the correlation structure simulation, we evaluate only sum counts edgeR, sum counts limma-voom , mean logcounts edgeR and mean logcounts limma-voom methods. 

In the Neuronal_excit cluster, we observe that the distribution of the logcounts for most genes detects outliers across samples, while in gene 10 sample LC016_WTA consists of the larger number of logcounts (Figures 1, 6, 11, 15). In the Neuronal_inhib cluster, we observe again the presence of outliers (Figure 2, 7, 12, 16).
  
All methods contain 43 differentially expressed genes for Neuronal_inhib cluster, 82 for Neuronal_excit cluster and 9424 equally shared between the two clusters (Figures 3, 8, 13, 17). Generally, compared to muscat simulation, the correlation structure reaches much smaller number of DE genes in the Neuronal_excit cluster as well as the two clusters share approximately more than the double number of genes among them( 9424 vs 4718 DE genes). 
  
In the t-SNE representation figures clusters are pretty dense and compact rendering the cell-populations very well-separated from one another compared to the muscat simulation (Figures 4, 9, 18).
  
Counts sum in edgeR method presents the best performance as it reaches the hightest TPR and lowest FDR followed counts sum in limma-voom and logcounts mean in edgeR. The logcounts mean in limma-voom underperforms as it contains an abnormally large FDR and TPR (Figures 5, 10, 14, 19). As a result, counts sum in edgeR and counts sum in limma voom methods overperform in the correlation structure simulation compared to muscat simulation as they attain larger TPR(70%\ vs 50%\). Also, logcounts mean in limma-voom method has ameliorated performance in muscat compared to correlation structure.
  
## True LogFC vs computed LogFC

In addition, we plot the simulated logFC (true) vs the computed logFC by the DE analysis. It is obvious that there seems to be an artefact in the muscat simulation. For some negative logFC (true) the computed logFC is positive. Generally, the Negative logFC is more noisy, which makes sense since the count numbers are lower.
```{r}
par(mfrow = c(2,2))
plot(lfc_mm_ni, lfc_res_mm_ni)
plot(lfc_mm_ne, lfc_res_mm_ne)
plot(lfc_ms_ni, lfc_res_ms_ni)
plot(lfc_ms_ne, lfc_res_ms_ne)

```


## TODO : True vs Predicted genes for each cluster
What is more, we calculate per cluster the true DE genes vs the predicted DE genes for both simulations. For cluster Neuronal_excit, ...

```{r}
#True vs predicted
g1 = upset(upset_data_mm_ne, empty.intersections = TRUE)
g2 = upset(upset_data_mm_ni, empty.intersections = TRUE)
g3 = upset(upset_data_ms_ne, empty.intersections = TRUE)
g4 = upset(upset_data_ms_ni, empty.intersections = TRUE)
print(g1)
print(g2)
print(g3)
print(g4)
```



# Conclusions

In conclusion, we devised a flexible gene correlation structure simulation framework on the differential expression, which justifies the covariance of genes as a result of the dependency of real biological variation across genes. In particular, the correlation structure ...[TODO add summmary of our simulation].  

For exploring the outcome of the gene-gene correlation on the differential expression (DE) analysis, we compared the gene correlation structure simulation with the muscat simulation framework. Particularly, we considered four different methods for the comparison, including sum counts in edgeR, sum counts in limma-voom, mean logcounts in edgeR as well as mean logcounts in limma-voom. We observed that all methods in the correlation structure framework, except the mean logcounts in limma-voom, presented burgeoning performance with 70%\ of TPR and extremely small FDR. Moreover, in the t-SNE representation the clusters are dense and compact, resulting in separating the cell populations to a great extent. 

[TODO] Add Results from upset plots with predicted vs true.


# Discussion

[TODO] maybe suggest something that could be extended in our simulation e.g library sizes

# References

[1] [](https://www.biorxiv.org/content/10.1101/713412v1.full)
[2] [](https://bioconductor.org/packages/release/bioc/html/scDblFinder.html)
[3] [](http://bioconductor.org/packages/release/bioc/html/scater.html) 
[4] [](https://bioconductor.org/packages/devel/bioc/vignettes/scater/inst/doc/overview.html#3_quality_control)
[5] Our analysis is based on [](https://github.com/HelenaLC/muscat/blob/master/vignettes/vignette.Rmd) and [](https://github.com/HelenaLC/BC2_2019-workshop_multi-scRNA-seq/blob/master/LPS)

