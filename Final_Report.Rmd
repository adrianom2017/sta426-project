---
title: "Final_Report"
author: "Adriano Martinelli, Chrysa Papadopoulou, Iliana Papadopoulou" 
date: "23/12/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
Single-cell RNA sequencing technologies allow the quantification of RNA molecules in biological samples in counts of reads mapped to the genes. Indeed, they are used to profile genome-wide high-resolution instances of gene expression activity and modifications in individual cells over time as well as monitor discrepancies in gene expression in different groups or treatments across conditions.However, the presence of multi-condition scRNA-seq datasets dictates the need to perform sample-level inferences.    

The aim of this project is to extend the simulation framework Muscat (Multi-sample multi-group scRNA-seq analysis tools) [1] established in the group of Prof. Mark Robinson in collaboration with Pierre Luc Germain. More precisely, the ``muscat`` simulation framework currently used in the group does not take the gene-gene correlation into account, sampling each gene in each cell independently. It is suspected that this may bias the evaluation of downstream analysis techniques. Since it is well known that gene-gene correlation is observed in real world data sets, the goal of our analysis is to explore the effect of gene-gene correlation on the differential expression (DE) analysis, while compairing it with the ``muscat`` simulation framework.

# Datasets

For performimg our simulations we utilized the single-cell RNA-seq of mouse cortex injected with Lipopolysaccharide (LPS) or with a vehicle treatment dataset (Crowell et al.)[1].

The class SingleCellExperiment keeps track of the counts and their associated metadata within a single object.

![](SingleCellExperiment_class.png)

## Preprocessing 

Firstly, we filter the doublet cells, produced directly from counts using overclustering-based generation of artifical doublets, separately on each sample using the scDblFinder class [2]. After removing genes that are not detected across all cells, we implement Quality control and filtering, using the R scater package [3], to correct for technical effects that distort the downstream analysis. In the provided SingleCellExperiment object, we also integrate various per-cell quality control statistics from perCellQCMetrics function. The first plot demonstrates an expected increasing number of detected genes with an increasing total count. Each point represents a cell that is coloured according to its cluster id. We then remove cells that have very few or many detected genes. Therefore, in the second figure we plot the distributions of QC metrics, the observation of which helps us to select the apprppriate thresholds for removing possible low-quality genes. 

A better way to choose these thresholds is implemented via the isOutlier function , where we exclude cells whose feature counts, number of detected features, and percentage of mitochondrial genes go beyond 2 Median Absolute Deviations (MADs) of the median and the percentage of mitochondrial genes overcomes 8\%. In addition, we plot the top 50  most-expressed features and subsequently remove the lowly expressed genes. Indeed, in the plot the rows correspond to genes and bars describe the expression of genes in single cells. Genes are sorted based on the median expression of each gene, which is indicated by circles.

We then calculate the distribution of percentages of the variance of the normalized log-expression values across cells that is explained by each variable/factor in the colData of our sce object, using the getVarianceExplained() function. In the density plot we observe that the percentages are generally small (0.08%,0.1%, 0.5%), meaning that that the expression profiles of most genes are not strongly associated with these factors. Finally, we compute that sum-factors, normalize data and visualize the expression values for a subset of genes (e.g the first 6 genes) across cells using the plotExpression() function. [4]


```{r, warning=FALSE}
#Load data
suppressPackageStartupMessages({
library(SingleCellExperiment)
library(scater)
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(grid)
library(edgeR)
library(irlba)
library(muscat)
library(countsimQC)
library(TMB)
library(cowplot)
library(scDblFinder)
library(dplyr)
library(UpSetR)
library(uwot)
library(Rtsne)  
  })
#library(sta426)#install_github(adrianom/sta426-project/sta426)

source('./Preprocessing_fun.R', echo=FALSE)

#Load object
sce = readRDS("week13_SCE_clustered.rds")
```

```{r, fig.cap=c('Plotting data','Distributions of QC metrics',"Top 50 most-expressed features","Distribution of percentages of variance explained across genes for various factors","Expression profile across cells")}

#sce= prep_steps(sce)

```

# Methods

## Simulation
We created a simulation framework that produces a correlation structure in the simulated counts to explore the effect of such correlation on analysis techniques. To make our results comprable to existing methods (muscat simulation framework) we tried to produce a simulation that allows us to generate data sets with similar characteristics as the muscat framework in terms of number of cells, number of samples, number of cluster and the distribution of those cells across samples and clusters. The typical input data set is a ``SingleCellExperiment`` file which consits of multiple wild types samples containing multiple cell types.

The pipeline of the simulation is:
* Generate correlation structure reflected in mean counts for each gene and cell
* Sample counts for each cell type and sample from a negative binomial distribution based on mean counts, gene-wise dispersion and library size
* Concatenate simulated data into a ``SingleCellExperiment``

### Generation of correlation structure
In a first step the ``SingleCellExperiment`` is subsected into each sample. Each sample is further subsected into the single cell types. This is the original data for a single simulation round, i.e. we construct the correlation structure for each cell type of each sample seperately as follows:

* Perform PCA on the data with gene as features
* Compute _k_-nearest neighbours of a cell
* Randomly select _N_ cells from the nearest neighbours with replacement
* Average the top principal components to create a artificial cell
* Project artificial cell from PCA space back into logcounts space

By averaging different subsets we obtain a correlation structure among the artificial cells. Note that we have to repeate this procedure for each cell type of each sample.

### Construct simulated ``SingleCellExperiment``
To obtain a complete artificial dataset we need to generate multiple samples with different cell types. Therefore we repeat the above described procedure for each cell type in a sample and for each sample in the original data set. This gives us a matrix of mean logcounts of the artificial cells each associated with a given cell type and sample id. We use convert this mean logcount matrix back to a count matrix and use this mean count matrix together with the gene-wise dispersion computed from the original data set as well as the library size of a given cell to generate artifical counts by sampling from a negative binomial distribution. This results in the final artifical count matrix.

### Simulation work-flow overview
We summarise this section by giving an overview of the whole procedure to generate the artificial counts:

* Prepare original data for simulation with ``prepSim()`` from ``muscat`` framework to filter the original data set
* For each sample and cell type generate the mean count based on PC averaging of a subset of _k_-nearest neigbours
* Based on mean count matrix, gene-wise dispersion and library size sample artificial counts from negative binomial

```{r}
#Load simulation functions
source('./fun.R', echo=FALSE)
```

## Run simulation
```{r}
##Prep data for simulation
if(length(grep("sce_prep",list.files()))){
  sce_prep = readRDS("sce_prep.RDS")
}else{
  sce_prep <- prepSCE(sce,
  cluster_id = "cluster_id",
  sample_id = "sample_id",
  group_id = "group_id",
  drop = FALSE)
  sce_prep <- prepSim(sce_prep)
  saveRDS(sce_prep, "sce_prep.RDS")
}

counts(sce_prep) = as.matrix(counts(sce_prep))
sce_prep = logNormCounts(sce_prep)

n_cluster = length(unique(colData(sce_prep)$cluster_id))
freq_cluster = table(colData(sce_prep)$cluster_id)
freq_cluster = freq_cluster / sum(freq_cluster)
n_sample = length(unique(colData(sce_prep)$sample_id))
n_group = 2

#Set params MUSCAT
n_genes = nrow(sce_prep)
n_cells_muscat = 100*n_sample
p_dd = c(0.9, 0, 0.1, 0, 0, 0)
probs = list(cluster = freq_cluster,
             sample = rep(1/n_sample, n_sample),
             group = rep(1/n_group, n_group))
lfc = 4

#Set params our simulation
n_comp = 10
n_cells = rep(n_cells_muscat / n_sample, n_sample)
kNN = 10
kNN_subsample = 5
#logFC = list(magnitude = lfc, proportion = p_dd[3]) #corresponds to p_dd
verbose = 0

#Run simulations
sce_muscat = simData(sce_prep, n_genes = n_genes, n_cells = n_cells_muscat, p_dd = p_dd, probs = probs, lfc = lfc)

#Extract meta data
meta = metadata(sce_muscat)$gene_info %>% select(cluster_id, logFC, sim_gene)
meta$logFC[is.na(meta$logFC)] = 0 

#Set up sce to replicate muscat simulation
gene_id = meta %>% filter(cluster_id == "Neuronal_excit") %>% select(sim_gene)
idx = sapply(gene_id$sim_gene, function(x){
  which(x == rownames(sce_prep))
})
#hist(table(idx))
sce_prep2 = sce_prep[idx,]
logFC = list("muscat_data" = meta)

#Run simulation
sce_sim = create_dataset(sce_prep2, n_comp, n_cells, kNN, kNN_subsample, n_sample, logFC, probs, verbose)

#Compare metadata
#head(metadata(sce_muscat)$gene_info,10)
#head(metadata(sce_sim)$gene_info,5)
#metadata(sce_sim)$cluster_info
```

## Augment data sets
```{r}
#Convert counts
sce_muscat = logNormCounts(sce_muscat)
logcounts(sce_prep) = as.matrix(logcounts(sce_prep))
counts(sce_prep) = as.matrix(counts(sce_prep))

#Populate sce_sim with reducedDim
sce_sim = runPCA(sce_sim)
sce_sim = runUMAP(sce_sim)
sce_sim = runTSNE(sce_sim)

#Populate sce_muscat with reducedDim
sce_muscat = runPCA(sce_muscat)
sce_muscat = runUMAP(sce_muscat)
sce_muscat = runTSNE(sce_muscat)

#Populate sce_wt with reducedDim
sce_prep = runPCA(sce_prep)
sce_prep = runUMAP(sce_prep)
sce_prep = runTSNE(sce_prep)
```

## Compare simulations
```{r}
subsample = sample(1:ncol(sce_prep), ncol(sce_sim))
  
#Distribution of counts
par(mfrow=c(3,1))
hist(logcounts(sce_prep)[sample(1:nrow(sce_prep), nrow(sce_sim))])
hist(logcounts(sce_muscat))
hist(logcounts(sce_sim))

#Sum of counts
countSum = data.frame(sce_prep = sum(counts(sce_prep)[,subsample]),
                      sce_muscat = sum(counts(sce_muscat)),
                      sce_sim = sum(counts(sce_sim)))
par(mfrow=c(1,1))
barplot(as.matrix(countSum), main = "Count sum of different SingleCellExperiment data sets")

table(metadata(sce_sim)$category)
table(metadata(sce_muscat)$category)

#Plot dim reductions
par(mfrow=c(3,1))
plotReducedDim(sce_prep, "PCA", colour_by = "cluster_id")
plotReducedDim(sce_muscat, "PCA", colour_by = "cluster_id", shape_by = "group_id")
plotReducedDim(sce_sim, "PCA", colour_by = "cluster_id", shape_by = "group_id")

par(mfrow=c(3,1))
plotReducedDim(sce_prep, "UMAP", colour_by = "cluster_id")
plotReducedDim(sce_muscat, "UMAP", colour_by = "cluster_id", shape_by = "group_id")
plotReducedDim(sce_sim, "UMAP", colour_by = "cluster_id", shape_by = "group_id")

par(mfrow=c(3,1))
plotReducedDim(sce_prep, "TSNE", colour_by = "cluster_id")
plotReducedDim(sce_muscat, "TSNE", colour_by = "cluster_id", shape_by = "group_id")
plotReducedDim(sce_sim, "TSNE", colour_by = "cluster_id", shape_by = "group_id")

#Cell-cell correlation structure
CellCellCor = list("sce_prep" = cor(counts(sce_prep)[,subsample]),
                   "sce_muscat" = cor(counts(sce_muscat)),
                   "sce_sim" = cor(counts(sce_sim)))

x = 1:ncol(sce_muscat)
par(mfrow = c(1,2))
image(x,x,CellCellCor$sce_muscat, axes = FALSE, xlab = '', ylab = '')
image(x,x,CellCellCor$sce_sim, axes = FALSE, xlab = '', ylab = '')

#Gene-Gene correlation structure
#GeneGeneCor = list("sce_prep" = cor(t(counts(sce_prep)[,subsample])),
#                   "sce_muscat" = cor(t(counts(sce_muscat))),
#                   "sce_sim" = cor(t(counts(sce_sim))))

# x = 1:nrow(sce_muscat)
# par(mar = c(5,6,6,4), cex = 0.5)
# image(x,x,GeneGeneCor$sce_muscat, axes = FALSE, xlab = '', ylab = '')

#Run count
DESeq_sim = DESeq2::DESeqDataSetFromMatrix(counts(sce_sim), colData(sce_sim), ~cluster_id*group_id)
DESeq_muscat = DESeq2::DESeqDataSetFromMatrix(counts(sce_muscat), colData(sce_muscat), ~cluster_id*group_id)
DESeq_prep = DESeq2::DESeqDataSetFromMatrix(counts(sce_prep), colData(sce_prep), ~cluster_id)

QCdata = list("Original" = DESeq_prep, "Muscat" = DESeq_muscat, "Sim" = DESeq_sim)

countsimQCReport(ddsList = QCdata, outputFile = "countsim_report_dream.html",
                 outputDir = "./CountSimReport_Dream/", outputFormat = "html_document", 
                 showCode = FALSE, forceOverwrite = TRUE,
                 savePlots = TRUE, description = "This is my test report.", 
                 maxNForCorr = 25, maxNForDisp = Inf, 
                 calculateStatistics = TRUE, subsampleSize = 25,
                 kfrac = 0.01, kmin = 5, 
                 permutationPvalues = FALSE, nPermutations = NULL)

```

## DE Analysis

The goal is to monitor population-specific state modifications across conditions. Consequently, we will test both aggregation-based approches (pbDS), which explicitly consider *pseudobulk* data and mixed models, which explicitly consider cell-level measurements (mmDS). In all cases, each gene is checked for state changes in each cluster.

Firstly, we aggregate measurements for each sample in each cluster to pseudobulk and create a MDS plot in pseuobulk-level to study the properties of samples. After reformatting the results, we filter them to keep hits with FDR < 5\% and visualize the top hits with the lowest adj. p-value in each cluster in the case of pseudobulk methods. On the other hand, in cell-level measurements, we use a mixed model for each gene, without aggragation beforehand. 

We simulate 7 methods in total, including sum counts in edgeR, sum counts in limma-voom, mean logcounts in edgeR, mean logcounts in limma-voom, mm dream, mm nbinom and mm vst DESeq, where in each case DE genes are retrieved when p-value<0.05. For each method we calculate the ground truth, which is included in the category column of the metadata of our sce object. [5]

### Visualization tools

For visualization analysis, we create violin plots, which constitute expression profiles for the top-8 DS genes with the lowest adj. p-value in Neuronal_excit and Neuronal_inhib clusters using the `plotExpression` function. We also use t-SNE representations colored by the expression of the top-8 DS genes, sampling at most 100 cells from each cluster. Moreover, we produce UpSet-plots for each method that visualizes the number of DE genes intersecting across clusters or the ones that are unique, as well as the number of DE and EE genes that are shared between different methods and the ground truth. In the end, we calculate the true positive rate (TPR) vs false discovery rate (FDR) for each method. [5]


```{r,message=FALSE}
source('./Muscat_Simulation_Fun.R', echo=FALSE)
```


```{r,fig.width=5}

Simulation_DS_analysis<-function(sce,pos,sim_type){
  #methods <- list("sum_counts_edgeR","sum_counts_limma-voom","mean_logcounts_edgeR",
  #           "mean_logcounts_limma-voom")
  methods <- list("sum_counts_edgeR")
  # methods <- list("sum_counts_edgeR","sum_counts_limma-voom","mean_logcounts_edgeR",
  #           "mean_logcounts_limma-voom","mm_dream","mm_nbinom","mm_vst_DESeq")
  
  #violin_1_plot  = list()
  #violin_2_plot  = list()
  #upset_plot_cluster = list()
  #ds_expression_plot = list()
  #TPR.vs.FDR_plot = list()

  num = 0
  for (method in methods){
    num = num +1
    method_pieces <- strsplit(method, "_")
    #print(method_pieces)
    method_substring <- matrix(unlist(method_pieces), ncol=3, byrow=TRUE)
    #print(method_substring)
    
    if (pos!=3 && pos!=4){
      print("Invalid gene_info argument position")
      break
    }
    
    topnumber = 0
    vst = NULL
    ds <- list()
    if (grepl("mm_",method)){
      if (method_substring[2] == "dream"){
        topnumber = 8
      }
      else if (method_substring[2] == "vst"){
        topnumber = 8
        vst = method_substring[3]
      }
      print(method)
      ds <- DS.analysis.mm(sce,method_substring[2],method_substring[1],vst,topnumber,pos)
      
      #Visualization
      plots <- DS.analysis.Visualization.mm(ds,method_substring[2],method_substring[1],vst,topnumber,num,sim_type)
      
    }
    else{
      if (!(method_substring[1] == "logcounts" && method_substring[3] == "edgeR")){
        topnumber = 8
      }
      
      #DS pb analysis
      ds <- DS.analysis.pd(sce,method_substring[2],method_substring[1],method_substring[3], topnumber,pos)
      #print("DS")
      #print(ds)
      #print("LEN Neur excit")
      #print(length(ds$res$table$B$Neuronal_excit$logFC)) # M : 6948, S : 9373
      # print("LEN Neur inhib")
      #print(length(ds$res$table$B$Neuronal_inhib$logFC)) # M : 4762 S : 9229
      #Visualization
      plots <- DS.analysis.Visualization.pb(ds,method_substring[2],method_substring[1],method_substring[3],topnumber,num,sim_type)
    
    }
    
  #  if (!(is_null(plots$v1))){
  #    violin_1_plot[[num]] <- plots$v1
  #  }
  #  if (!is_null(plots$v2)){
  #     violin_2_plot[[num]] <- plots$v2
  #  }
    
  #  if (!is_null(plots$upset)){
  #    upset_plot_cluster[[num]] <-  plots$upset
  #  }
  #  if (!is_null(plots$ds_expression)){
  #    ds_expression_plot[[num]] <- plots$ds_expression
  #  }
  #  if (!is_null(plots$TPR.vs.FDR)){
  #    TPR.vs.FDR_plot[[num]] <- plots$TPR.vs.FDR
  # }
  


    print("DONE!!")
    for(element in plots){
      if (!is_null(element)){
        print(element) 
      }
    
    }
    #break
  
  }
 
  # violin_1 = plot_grid(plotlist=violin_1_plot,labels = c('A', 'B','C','D','E','F','G'), label_size = 12)
  #violin_2 =  plot_grid(plotlist=violin_2_plot,labels =  c('A', 'B','C','D','E','F','G'), label_size = 12)
  #upset = plot_grid(plotlist=upset_plot_cluster,labels =  c('A', 'B','C','D','E','F','G'), label_size = 12)
  #ds_expression = plot_grid(plotlist=ds_expression_plot,labels =  c('A', 'B','C','D','E','F','G'), label_size = 12)
  #TPR.vs.FDR = plot_grid(plotlist=TPR.vs.FDR_plot,labels =  c('A', 'B','C','D','E','F','G'), label_size = 12)
  
  #save_plot("violin_1.png", violin_1, ncol = 1)
  #save_plot("violin_2.png", violin_2, ncol = 1)
  #save_plot("upset.png", upset, ncol = 1)
  #save_plot("ds_expression.png", ds_expression, ncol = 1)
  #save_plot("TPR.vs.FDR.png", TPR.vs.FDR, ncol = 1)
}


```

##  Muscat Simulation
```{r}
Simulation_DS_analysis(sce_muscat,3,"muscat")
```

## Our Simulation
```{r}
Simulation_DS_analysis(sce_sim,4,"correlation_structure")
```
# Simulation Quality Control
```{r}
res_muscat = readRDS("output/muscat/DS_results_counts_sum_edgeR.rds")
res_sim = readRDS("output/correlation_structure/DS_results_counts_sum_edgeR.rds")
```

```{r}
#Obtain all idx for the genes in DE analysis
idx_sim_ne = sapply(res_sim$table$B$Neuronal_excit$gene, function(x){
  which(x == rownames(sce_sim))
})

idx_sim_ni = sapply(res_sim$table$B$Neuronal_inhib$gene, function(x){
  which(x == rownames(sce_sim))
})

idx_mu_ne = sapply(res_muscat$table$B$Neuronal_excit$gene, function(x){
  which(x == rownames(sce_muscat))
})

idx_mu_ni = sapply(res_muscat$table$B$Neuronal_inhib$gene, function(x){
  which(x == rownames(sce_muscat))
})

```

```{r}
#Construct vectors of logFC for the genes in the analysis
mm = metadata(sce_muscat)
ms = metadata(sce_sim)

lfc_mm_ne = mm$gene_info %>% filter(cluster_id == "Neuronal_excit") %>% select(logFC)
lfc_mm_ne = lfc_mm_ne$logFC
lfc_mm_ne[is.na(lfc_mm_ne)] = 0
lfc_mm_ne = lfc_mm_ne[idx_mu_ne]

lfc_mm_ni = mm$gene_info %>% filter(cluster_id == "Neuronal_inhib") %>% select(logFC)
lfc_mm_ni = lfc_mm_ni$logFC
lfc_mm_ni[is.na(lfc_mm_ni)] = 0
lfc_mm_ni = lfc_mm_ni[idx_mu_ni]

lfc_ms_ne = ms$gene_info2 %>% filter(cluster_id == "Neuronal_excit") %>% select(logFC)
lfc_ms_ne = lfc_ms_ne$logFC
lfc_ms_ne = lfc_ms_ne[idx_sim_ne]

lfc_ms_ni = ms$gene_info2 %>% filter(cluster_id == "Neuronal_inhib") %>% select(logFC)
lfc_ms_ni = lfc_ms_ni$logFC
lfc_ms_ni = lfc_ms_ni[idx_sim_ni]

lfc_res_mm_ne = res_muscat$table$B$Neuronal_excit$logFC
lfc_res_mm_ni = res_muscat$table$B$Neuronal_inhib$logFC

lfc_res_ms_ne = res_sim$table$B$Neuronal_excit$logFC
lfc_res_ms_ni = res_sim$table$B$Neuronal_inhib$logFC
```

```{r}
#plot simulated logFC (true) vs computed logFC by DE analysis
#comment there seems to be an artefact in the muscat simulation. We see the for some negative logFC (true) the computed logFC is positive
#In general: Negativ logFC is more noisy. Which makes sense since count numbers are lower
par(mfrow = c(2,2))
plot(lfc_mm_ni, lfc_res_mm_ni)
plot(lfc_mm_ne, lfc_res_mm_ne)
plot(lfc_ms_ni, lfc_res_ms_ni)
plot(lfc_ms_ne, lfc_res_ms_ne)

```


#Upset plots
```{r}
#Construct vectors of p.adj for the genes in the analysis
mm = metadata(sce_muscat)
ms = metadata(sce_sim)

DE_mm_ne = mm$gene_info %>% filter(cluster_id == "Neuronal_excit") %>% select(logFC)
DE_mm_ne = DE_mm_ne$logFC
DE_mm_ne[is.na(DE_mm_ne)] = 0
DE_mm_ne = DE_mm_ne[idx_mu_ne]
DE_mm_ne[DE_mm_ne != 0] = 1 #set all DE genes to 1

DE_mm_ni = mm$gene_info %>% filter(cluster_id == "Neuronal_inhib") %>% select(logFC)
DE_mm_ni = DE_mm_ni$logFC
DE_mm_ni[is.na(DE_mm_ni)] = 0
DE_mm_ni = DE_mm_ni[idx_mu_ni]
DE_mm_ni[DE_mm_ni != 0] = 1 #set all DE genes to 1

DE_ms_ne = ms$gene_info2 %>% filter(cluster_id == "Neuronal_excit") %>% select(logFC)
DE_ms_ne = DE_ms_ne$logFC
DE_ms_ne = DE_ms_ne[idx_sim_ne]
DE_ms_ne[DE_ms_ne != 0] = 1

DE_ms_ni = ms$gene_info2 %>% filter(cluster_id == "Neuronal_inhib") %>% select(logFC)
DE_ms_ni = DE_ms_ni$logFC
DE_ms_ni = DE_ms_ni[idx_sim_ni]
DE_ms_ni[DE_ms_ni != 0] = 1

DE_res_mm_ne = rep(0, nrow(res_muscat$table$B$Neuronal_excit))
DE_res_mm_ne[res_muscat$table$B$Neuronal_excit$p_adj.loc <= 0.05] = 1
DE_res_mm_ni = rep(0, nrow(res_muscat$table$B$Neuronal_inhib))
DE_res_mm_ni[res_muscat$table$B$Neuronal_inhib$p_adj.loc <= 0.05] = 1

DE_res_ms_ne = rep(0, nrow(res_sim$table$B$Neuronal_excit))
DE_res_ms_ne[res_sim$table$B$Neuronal_excit$p_adj.loc <= 0.05] = 1
DE_res_ms_ni = rep(0, nrow(res_sim$table$B$Neuronal_inhib))
DE_res_ms_ni[res_sim$table$B$Neuronal_inhib$p_adj.loc <= 0.05] = 1

#Upset true vs predicted
upset_data_mm_ne = data.frame(True = DE_mm_ne, Predicted = DE_res_mm_ne)
upset_data_mm_ni = data.frame(True = DE_mm_ni, Predicted = DE_res_mm_ni)
upset_data_ms_ne = data.frame(True = DE_ms_ne, Predicted = DE_res_ms_ne)
upset_data_ms_ni = data.frame(True = DE_ms_ni, Predicted = DE_res_ms_ni)
```

```{r}
#True vs predicted
g1 = upset(upset_data_mm_ne, empty.intersections = TRUE)
g2 = upset(upset_data_mm_ni, empty.intersections = TRUE)
g3 = upset(upset_data_ms_ne, empty.intersections = TRUE)
g4 = upset(upset_data_ms_ni, empty.intersections = TRUE)
g1
g2
g3
g4
```

```{r}
# Concatenate all .rds files together
library(tidyverse)
sce_all_methods <- do.call('rbind', lapply(list.files(path = "output/muscat", full.names = TRUE), readRDS))
```

```{r}
print(sce_all_methods)
```

```{r}
length(sce_all_methods)
print(sce_all_methods[3])
print(upset(fromList(ds_gs), sets = levels(sce_all_methods)))
```
# Results

From the upsets plots above we observe that the number of differentially expressed genes for Neuronal_inhib is 4, for Neuronal_excit is 36. Moreover, it is evident that Neuronal_inhib and Neuronal_excit share 208 differentially expressed genes.


From the upsets plots above we observe that for methods "dream" and "nbinom" the number of differentially expressed genes for Neuronal_inhib is 0, for Neuronal_excit is 43. Moreover, it is evident that Neuronal_inhib and Neuronal_excit share 68 differentially expressed genes.
On ther other hand, for method "vst" with "DESeq2",  the number of differentially expressed genes for Neuronal_inhib and Neuronal_excit is 0 and both share 500 DE genes.

FDR cutoffs of 1%, 5%, and 10%; dashed lines indicate desired FDRs

# Conclusions

# Discussion

# Refereneces

[1] https://www.biorxiv.org/content/10.1101/713412v1.full
[2] https://bioconductor.org/packages/release/bioc/html/scDblFinder.html
[3] http://bioconductor.org/packages/release/bioc/html/scater.html 
[4] https://bioconductor.org/packages/devel/bioc/vignettes/scater/inst/doc/overview.html#3_quality_control
[5] Our analysis is based on https://github.com/HelenaLC/muscat/blob/master/vignettes/vignette.Rmd and https://github.com/HelenaLC/BC2_2019-workshop_multi-scRNA-seq/blob/master/LPS

